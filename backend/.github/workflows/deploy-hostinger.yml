name: Deploy to Hostinger VPS

on:
  push:
    branches: [main, production]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

env:
  NODE_VERSION: '20'
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/backend

jobs:
  # Job 1: Build and Test
  build-and-test:
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
    - name: ğŸ” Checkout code
      uses: actions/checkout@v4

    - name: ğŸŸ¢ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: backend/package-lock.json

    - name: ğŸ“¦ Install dependencies
      working-directory: ./backend
      run: npm ci

    - name: ğŸ” Run linting
      working-directory: ./backend
      run: npm run lint
      continue-on-error: true

    - name: ğŸ” Type checking
      working-directory: ./backend
      run: npm run build

    - name: ğŸ§ª Run tests
      working-directory: ./backend
      run: npm test
      env:
        NODE_ENV: test
        JWT_SECRET: test-secret
        JWT_REFRESH_SECRET: test-refresh-secret

    - name: ğŸ” Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.DOCKER_REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: ğŸ·ï¸ Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: ğŸ—ï¸ Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        file: ./backend/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        platforms: linux/amd64
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Job 2: Security Scan
  security-scan:
    runs-on: ubuntu-latest
    needs: build-and-test
    
    steps:
    - name: ğŸ” Checkout code
      uses: actions/checkout@v4

    - name: ğŸ”’ Run security audit
      working-directory: ./backend
      run: npm audit --audit-level moderate
      continue-on-error: true

    - name: ğŸ›¡ï¸ Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ needs.build-and-test.outputs.image-tag }}
        format: 'sarif'
        output: 'trivy-results.sarif'
      continue-on-error: true

  # Job 3: Deploy to Hostinger VPS
  deploy:
    runs-on: ubuntu-latest
    needs: [build-and-test, security-scan]
    environment: 
      name: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
      url: ${{ vars.APP_URL }}
    
    steps:
    - name: ğŸ” Checkout code
      uses: actions/checkout@v4

    - name: ğŸ”§ Setup deployment environment
      run: |
        echo "DEPLOYMENT_ENV=${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}" >> $GITHUB_ENV
        echo "IMAGE_TAG=${{ needs.build-and-test.outputs.image-tag }}" >> $GITHUB_ENV

    - name: ğŸ“ Create deployment script
      run: |
        cat > deploy.sh << 'EOF'
        #!/bin/bash
        set -e
        
        # Colors for output
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[1;33m'
        NC='\033[0m'
        
        echo -e "${GREEN}ğŸš€ Starting deployment to Hostinger VPS...${NC}"
        
        # Variables
        APP_NAME="fuseloja-backend"
        APP_DIR="/opt/$APP_NAME"
        DOCKER_IMAGE="${{ env.IMAGE_TAG }}"
        ENVIRONMENT="${{ env.DEPLOYMENT_ENV }}"
        
        # Create application directory
        echo -e "${YELLOW}ğŸ“ Setting up application directory...${NC}"
        sudo mkdir -p $APP_DIR
        cd $APP_DIR
        
        # Stop existing containers
        echo -e "${YELLOW}ğŸ›‘ Stopping existing containers...${NC}"
        sudo docker-compose down --remove-orphans || true
        
        # Login to registry
        echo -e "${YELLOW}ğŸ” Logging into container registry...${NC}"
        echo "${{ secrets.GITHUB_TOKEN }}" | sudo docker login ghcr.io -u ${{ github.actor }} --password-stdin
        
        # Pull latest image
        echo -e "${YELLOW}ğŸ“¥ Pulling latest Docker image...${NC}"
        sudo docker pull $DOCKER_IMAGE
        
        # Create docker-compose.yml
        echo -e "${YELLOW}âš™ï¸ Creating Docker Compose configuration...${NC}"
        cat > docker-compose.yml << 'COMPOSE_EOF'
        version: '3.8'
        
        services:
          backend:
            image: ${{ env.IMAGE_TAG }}
            container_name: ${APP_NAME}
            restart: unless-stopped
            ports:
              - "3000:3000"
            environment:
              - NODE_ENV=${ENVIRONMENT}
              - PORT=3000
              - DATABASE_URL=/app/data/app.db
              - JWT_SECRET=${{ secrets.JWT_SECRET }}
              - JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}
              - EMAIL_HOST=${{ secrets.EMAIL_HOST }}
              - EMAIL_PORT=${{ secrets.EMAIL_PORT }}
              - EMAIL_USER=${{ secrets.EMAIL_USER }}
              - EMAIL_PASSWORD=${{ secrets.EMAIL_PASSWORD }}
              - CORS_ORIGINS=${{ vars.CORS_ORIGINS }}
            volumes:
              - ./data:/app/data
              - ./uploads:/app/uploads
              - ./logs:/app/logs
              - ./backups:/app/backups
            networks:
              - backend-network
            healthcheck:
              test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
              interval: 30s
              timeout: 10s
              retries: 3
              start_period: 40s
        
          nginx:
            image: nginx:alpine
            container_name: ${APP_NAME}-nginx
            restart: unless-stopped
            ports:
              - "80:80"
              - "443:443"
            volumes:
              - ./nginx.conf:/etc/nginx/nginx.conf:ro
              - ./ssl:/etc/nginx/ssl:ro
              - /var/log/nginx:/var/log/nginx
            depends_on:
              - backend
            networks:
              - backend-network
        
        networks:
          backend-network:
            driver: bridge
        
        volumes:
          backend-data:
        COMPOSE_EOF
        
        # Create Nginx configuration
        echo -e "${YELLOW}ğŸŒ Creating Nginx configuration...${NC}"
        cat > nginx.conf << 'NGINX_EOF'
        events {
            worker_connections 1024;
        }
        
        http {
            upstream backend {
                server backend:3000;
            }
        
            # Rate limiting
            limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
        
            # Security headers
            add_header X-Frame-Options DENY;
            add_header X-Content-Type-Options nosniff;
            add_header X-XSS-Protection "1; mode=block";
            add_header Strict-Transport-Security "max-age=31536000; includeSubDomains";
        
            server {
                listen 80;
                server_name ${{ vars.DOMAIN_NAME }};
        
                # Redirect HTTP to HTTPS
                return 301 https://$server_name$request_uri;
            }
        
            server {
                listen 443 ssl http2;
                server_name ${{ vars.DOMAIN_NAME }};
        
                # SSL Configuration
                ssl_certificate /etc/nginx/ssl/fullchain.pem;
                ssl_certificate_key /etc/nginx/ssl/privkey.pem;
                ssl_protocols TLSv1.2 TLSv1.3;
                ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
                ssl_prefer_server_ciphers off;
        
                # Proxy settings
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
        
                # API routes
                location /api/ {
                    limit_req zone=api burst=20 nodelay;
                    proxy_pass http://backend;
                    proxy_connect_timeout 60s;
                    proxy_send_timeout 60s;
                    proxy_read_timeout 60s;
                }
        
                # WebSocket
                location /socket.io/ {
                    proxy_pass http://backend;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade $http_upgrade;
                    proxy_set_header Connection "upgrade";
                    proxy_set_header Host $host;
                }
        
                # Health check
                location /health {
                    proxy_pass http://backend;
                    access_log off;
                }
        
                # Default location
                location / {
                    proxy_pass http://backend;
                }
            }
        }
        NGINX_EOF
        
        # Create directories
        echo -e "${YELLOW}ğŸ“ Creating data directories...${NC}"
        sudo mkdir -p data uploads logs backups ssl
        sudo chown -R 1001:1001 data uploads logs backups
        
        # Start services
        echo -e "${YELLOW}ğŸš€ Starting services...${NC}"
        sudo docker-compose up -d
        
        # Wait for services to be ready
        echo -e "${YELLOW}â³ Waiting for services to be ready...${NC}"
        sleep 30
        
        # Health check
        echo -e "${YELLOW}ğŸ” Running health check...${NC}"
        max_attempts=10
        attempt=1
        
        while [ $attempt -le $max_attempts ]; do
            if curl -f http://localhost:3000/health > /dev/null 2>&1; then
                echo -e "${GREEN}âœ… Backend is healthy!${NC}"
                break
            else
                echo -e "${YELLOW}â³ Attempt $attempt/$max_attempts - Backend not ready yet...${NC}"
                sleep 10
                attempt=$((attempt + 1))
            fi
        done
        
        if [ $attempt -gt $max_attempts ]; then
            echo -e "${RED}âŒ Health check failed after $max_attempts attempts${NC}"
            sudo docker-compose logs backend
            exit 1
        fi
        
        # Clean up old images
        echo -e "${YELLOW}ğŸ§¹ Cleaning up old Docker images...${NC}"
        sudo docker image prune -f
        
        echo -e "${GREEN}ğŸ‰ Deployment completed successfully!${NC}"
        echo -e "${GREEN}ğŸ“Š Service status:${NC}"
        sudo docker-compose ps
        
        EOF
        
        chmod +x deploy.sh

    - name: ğŸš€ Deploy to VPS
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USERNAME }}
        key: ${{ secrets.VPS_SSH_KEY }}
        port: ${{ secrets.VPS_PORT || 22 }}
        script_stop: true
        script: |
          # Transfer and execute deployment script
          cat > /tmp/deploy.sh << 'EOF'
          ${{ steps.deploy.outputs.script }}
          EOF
          chmod +x /tmp/deploy.sh
          /tmp/deploy.sh

    - name: ğŸ”’ Setup SSL Certificate
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USERNAME }}
        key: ${{ secrets.VPS_SSH_KEY }}
        port: ${{ secrets.VPS_PORT || 22 }}
        script: |
          # Install Certbot if not exists
          if ! command -v certbot &> /dev/null; then
            sudo apt update
            sudo apt install -y certbot
          fi
          
          # Stop nginx temporarily
          sudo docker-compose -f /opt/fuseloja-backend/docker-compose.yml stop nginx
          
          # Get SSL certificate
          sudo certbot certonly --standalone \
            --non-interactive \
            --agree-tos \
            --email ${{ secrets.SSL_EMAIL }} \
            -d ${{ vars.DOMAIN_NAME }}
          
          # Copy certificates
          sudo cp /etc/letsencrypt/live/${{ vars.DOMAIN_NAME }}/fullchain.pem /opt/fuseloja-backend/ssl/
          sudo cp /etc/letsencrypt/live/${{ vars.DOMAIN_NAME }}/privkey.pem /opt/fuseloja-backend/ssl/
          sudo chmod 644 /opt/fuseloja-backend/ssl/*.pem
          
          # Restart nginx
          sudo docker-compose -f /opt/fuseloja-backend/docker-compose.yml start nginx
          
          # Setup SSL renewal cron job
          (crontab -l 2>/dev/null; echo "0 12 * * * /usr/bin/certbot renew --quiet --post-hook 'docker-compose -f /opt/fuseloja-backend/docker-compose.yml restart nginx'") | crontab -

    - name: ğŸ§ª Post-deployment verification
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USERNAME }}
        key: ${{ secrets.VPS_SSH_KEY }}
        port: ${{ secrets.VPS_PORT || 22 }}
        script: |
          echo "ğŸ” Running post-deployment verification..."
          
          # Test HTTP redirect
          if curl -sL -w "%{http_code}" "http://${{ vars.DOMAIN_NAME }}/health" -o /dev/null | grep -q "301"; then
            echo "âœ… HTTP to HTTPS redirect working"
          else
            echo "âŒ HTTP redirect not working"
          fi
          
          # Test HTTPS endpoint
          if curl -f "https://${{ vars.DOMAIN_NAME }}/health"; then
            echo "âœ… HTTPS endpoint working"
          else
            echo "âŒ HTTPS endpoint not working"
          fi
          
          # Test API endpoint
          if curl -f "https://${{ vars.DOMAIN_NAME }}/api/v1/health"; then
            echo "âœ… API endpoint working"
          else
            echo "âŒ API endpoint not working"
          fi
          
          # Show service status
          echo "ğŸ“Š Service status:"
          sudo docker-compose -f /opt/fuseloja-backend/docker-compose.yml ps

  # Job 4: Notify
  notify:
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    
    steps:
    - name: ğŸ“§ Notify deployment success
      if: needs.deploy.result == 'success'
      run: |
        echo "ğŸ‰ Deployment to Hostinger VPS completed successfully!"
        echo "ğŸŒ Application URL: https://${{ vars.DOMAIN_NAME }}"
        echo "ğŸ“Š API Health: https://${{ vars.DOMAIN_NAME }}/health"
        echo "ğŸ“š API Docs: https://${{ vars.DOMAIN_NAME }}/api-docs"

    - name: ğŸ“§ Notify deployment failure
      if: needs.deploy.result == 'failure'
      run: |
        echo "âŒ Deployment to Hostinger VPS failed!"
        echo "Please check the deployment logs for details."

  # Job 5: Cleanup
  cleanup:
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    
    steps:
    - name: ğŸ§¹ Clean up old container images
      uses: actions/delete-package-versions@v4
      with:
        package-name: ${{ github.event.repository.name }}/backend
        package-type: 'container'
        min-versions-to-keep: 5
        delete-only-untagged-versions: 'true'
      continue-on-error: true 