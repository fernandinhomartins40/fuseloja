name: Deploy Full Stack to Hostinger VPS

on:
  push:
    branches: [main, production]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

env:
  NODE_VERSION: '20'
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/fullstack

jobs:
  # Job 1: Build and Test Frontend + Backend
  build-and-test:
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
    - name: ğŸ” Checkout code
      uses: actions/checkout@v4

    - name: ğŸŸ¢ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    # Frontend Build
    - name: ğŸ“¦ Install frontend dependencies
      run: npm ci

    - name: ğŸ” Frontend linting
      run: npm run lint
      continue-on-error: true

    - name: ğŸ” Frontend type checking
      run: npx tsc --noEmit
      continue-on-error: true

    - name: ğŸ—ï¸ Build frontend
      run: npm run build
      env:
        VITE_API_BASE_URL: /api
        VITE_API_PREFIX: /v1

    # Backend Build
    - name: ğŸ“¦ Install backend dependencies
      working-directory: ./backend
      run: npm ci

    - name: ğŸ” Backend linting
      working-directory: ./backend
      run: npm run lint
      continue-on-error: true

    - name: ğŸ” Backend type checking
      working-directory: ./backend
      run: npm run build

    - name: ğŸ§ª Run backend tests
      working-directory: ./backend
      run: npm test
      env:
        NODE_ENV: test
        JWT_SECRET: test-secret
        JWT_REFRESH_SECRET: test-refresh-secret

    - name: ğŸ” Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.DOCKER_REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: ğŸ·ï¸ Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: ğŸ—ï¸ Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile.fullstack
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        platforms: linux/amd64
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Job 2: Security Scan
  security-scan:
    runs-on: ubuntu-latest
    needs: build-and-test
    
    steps:
    - name: ğŸ” Checkout code
      uses: actions/checkout@v4

    - name: ğŸ”’ Run security audit
      working-directory: ./backend
      run: npm audit --audit-level moderate
      continue-on-error: true

    - name: ğŸ›¡ï¸ Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ needs.build-and-test.outputs.image-tag }}
        format: 'sarif'
        output: 'trivy-results.sarif'
      continue-on-error: true

  # Job 3: Deploy to Hostinger VPS
  deploy:
    runs-on: ubuntu-latest
    needs: [build-and-test, security-scan]
    environment: 
      name: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
      url: ${{ vars.APP_URL }}
    
    steps:
    - name: ğŸ” Checkout code
      uses: actions/checkout@v4

    - name: ğŸ”§ Setup deployment environment
      run: |
        echo "DEPLOYMENT_ENV=${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}" >> $GITHUB_ENV
        echo "IMAGE_TAG=${{ needs.build-and-test.outputs.image-tag }}" >> $GITHUB_ENV

    - name: ğŸ“ Create deployment script
      run: |
        cat > deploy.sh << 'EOF'
        #!/bin/bash
        set -e
        
        # Colors for output
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[1;33m'
        NC='\033[0m'
        
        echo -e "${GREEN}ğŸš€ Starting deployment to Hostinger VPS...${NC}"
        
                 # Variables
         APP_NAME="fuseloja-fullstack"
         APP_DIR="/opt/$APP_NAME"
         DOCKER_IMAGE="${{ env.IMAGE_TAG }}"
         ENVIRONMENT="${{ env.DEPLOYMENT_ENV }}"
        
        # Create application directory
        echo -e "${YELLOW}ğŸ“ Setting up application directory...${NC}"
        sudo mkdir -p $APP_DIR
        cd $APP_DIR
        
        # Stop existing containers
        echo -e "${YELLOW}ğŸ›‘ Stopping existing containers...${NC}"
        sudo docker-compose down --remove-orphans || true
        
        # Login to registry
        echo -e "${YELLOW}ğŸ” Logging into container registry...${NC}"
        echo "${{ secrets.GITHUB_TOKEN }}" | sudo docker login ghcr.io -u ${{ github.actor }} --password-stdin
        
        # Pull latest image
        echo -e "${YELLOW}ğŸ“¥ Pulling latest Docker image...${NC}"
        sudo docker pull $DOCKER_IMAGE
        
                 # Create docker-compose.yml
         echo -e "${YELLOW}âš™ï¸ Creating Docker Compose configuration...${NC}"
         cat > docker-compose.yml << 'COMPOSE_EOF'
         version: '3.8'
         
         services:
           app:
             image: ${{ env.IMAGE_TAG }}
             container_name: ${APP_NAME}
             restart: unless-stopped
             ports:
               - "3000:3000"
             environment:
               - NODE_ENV=${ENVIRONMENT}
               - PORT=3000
               - DATABASE_URL=/app/data/app.db
               - JWT_SECRET=${{ secrets.JWT_SECRET }}
               - JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}
               - EMAIL_HOST=${{ secrets.EMAIL_HOST }}
               - EMAIL_PORT=${{ secrets.EMAIL_PORT }}
               - EMAIL_USER=${{ secrets.EMAIL_USER }}
               - EMAIL_PASSWORD=${{ secrets.EMAIL_PASSWORD }}
               - CORS_ORIGINS=${{ vars.CORS_ORIGINS }}
             volumes:
               - ./data:/app/data
               - ./uploads:/app/uploads
               - ./logs:/app/logs
               - ./backups:/app/backups
             networks:
               - app-network
             healthcheck:
               test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
               interval: 30s
               timeout: 10s
               retries: 3
               start_period: 40s
        
                     nginx:
             image: nginx:alpine
             container_name: ${APP_NAME}-nginx
             restart: unless-stopped
             ports:
               - "80:80"
               - "443:443"
             volumes:
               - ./nginx.conf:/etc/nginx/nginx.conf:ro
               - ./ssl:/etc/nginx/ssl:ro
               - /var/log/nginx:/var/log/nginx
             depends_on:
               - app
             networks:
               - app-network
         
         networks:
           app-network:
             driver: bridge
        
        volumes:
          backend-data:
        COMPOSE_EOF
        
                 # Create Nginx configuration
         echo -e "${YELLOW}ğŸŒ Creating Nginx configuration...${NC}"
         cat > nginx.conf << 'NGINX_EOF'
         events {
             worker_connections 1024;
         }
         
         http {
             upstream backend {
                 server app:3000;
             }
         
             # MIME types
             include /etc/nginx/mime.types;
             default_type application/octet-stream;
         
             # Compression
             gzip on;
             gzip_vary on;
             gzip_min_length 1024;
             gzip_proxied expired no-cache no-store private must-revalidate auth;
             gzip_types text/plain text/css text/xml text/javascript application/javascript application/xml+rss application/json;
         
             # Rate limiting
             limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
             limit_req_zone $binary_remote_addr zone=general:10m rate=30r/s;
         
             # Security headers
             add_header X-Frame-Options DENY;
             add_header X-Content-Type-Options nosniff;
             add_header X-XSS-Protection "1; mode=block";
             add_header Strict-Transport-Security "max-age=31536000; includeSubDomains";
             add_header Referrer-Policy "strict-origin-when-cross-origin";
         
             server {
                 listen 80;
                 server_name ${{ vars.DOMAIN_NAME }};
         
                 # Redirect HTTP to HTTPS
                 return 301 https://$server_name$request_uri;
             }
         
             server {
                 listen 443 ssl http2;
                 server_name ${{ vars.DOMAIN_NAME }};
         
                 # SSL Configuration
                 ssl_certificate /etc/nginx/ssl/fullchain.pem;
                 ssl_certificate_key /etc/nginx/ssl/privkey.pem;
                 ssl_protocols TLSv1.2 TLSv1.3;
                 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
                 ssl_prefer_server_ciphers off;
         
                 # Proxy settings
                 proxy_set_header Host $host;
                 proxy_set_header X-Real-IP $remote_addr;
                 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                 proxy_set_header X-Forwarded-Proto $scheme;
         
                 # Static frontend files (cached)
                 location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
                     root /var/www/html;
                     expires 1y;
                     add_header Cache-Control "public, immutable";
                     access_log off;
                     try_files $uri =404;
                 }
         
                 # API routes
                 location /api/ {
                     limit_req zone=api burst=20 nodelay;
                     proxy_pass http://backend;
                     proxy_connect_timeout 60s;
                     proxy_send_timeout 60s;
                     proxy_read_timeout 60s;
                 }
         
                 # WebSocket
                 location /socket.io/ {
                     proxy_pass http://backend;
                     proxy_http_version 1.1;
                     proxy_set_header Upgrade $http_upgrade;
                     proxy_set_header Connection "upgrade";
                     proxy_set_header Host $host;
                 }
         
                 # Health check
                 location /health {
                     proxy_pass http://backend;
                     access_log off;
                 }
         
                 # Admin panel (if needed)
                 location /admin {
                     limit_req zone=general burst=10 nodelay;
                     root /var/www/html;
                     try_files $uri $uri/ /index.html;
                 }
         
                 # Frontend SPA - serve index.html for all other routes
                 location / {
                     limit_req zone=general burst=30 nodelay;
                     root /var/www/html;
                     try_files $uri $uri/ /index.html;
                     
                     # Security headers for HTML
                     add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.gpteng.co https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; img-src 'self' data: https:; font-src 'self' https://cdn.jsdelivr.net; connect-src 'self' https:; frame-src 'none';" always;
                 }
             }
         }
         NGINX_EOF
        
        # Create directories
        echo -e "${YELLOW}ğŸ“ Creating data directories...${NC}"
        sudo mkdir -p data uploads logs backups ssl
        sudo chown -R 1001:1001 data uploads logs backups
        
        # Start services
        echo -e "${YELLOW}ğŸš€ Starting services...${NC}"
        sudo docker-compose up -d
        
        # Wait for services to be ready
        echo -e "${YELLOW}â³ Waiting for services to be ready...${NC}"
        sleep 30
        
        # Health check
        echo -e "${YELLOW}ğŸ” Running health check...${NC}"
        max_attempts=10
        attempt=1
        
        while [ $attempt -le $max_attempts ]; do
            if curl -f http://localhost:3000/health > /dev/null 2>&1; then
                echo -e "${GREEN}âœ… Backend is healthy!${NC}"
                break
            else
                echo -e "${YELLOW}â³ Attempt $attempt/$max_attempts - Backend not ready yet...${NC}"
                sleep 10
                attempt=$((attempt + 1))
            fi
        done
        
        if [ $attempt -gt $max_attempts ]; then
            echo -e "${RED}âŒ Health check failed after $max_attempts attempts${NC}"
            sudo docker-compose logs backend
            exit 1
        fi
        
        # Clean up old images
        echo -e "${YELLOW}ğŸ§¹ Cleaning up old Docker images...${NC}"
        sudo docker image prune -f
        
        echo -e "${GREEN}ğŸ‰ Deployment completed successfully!${NC}"
        echo -e "${GREEN}ğŸ“Š Service status:${NC}"
        sudo docker-compose ps
        
        EOF
        
        chmod +x deploy.sh

    - name: ğŸš€ Deploy to VPS
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.SSH_HOST }}
        username: ${{ secrets.SSH_USERNAME }}
        password: ${{ secrets.SSH_PASSWORD }}
        port: 22
        script_stop: true
        script: |
          set -e
          
          # Colors for output
          RED='\033[0;31m'
          GREEN='\033[0;32m'
          YELLOW='\033[1;33m'
          NC='\033[0m'
          
          echo -e "${GREEN}ğŸš€ Starting deployment to Fuseloja VPS...${NC}"
          
          # Variables
          APP_NAME="fuseloja-fullstack"
          APP_DIR="/opt/$APP_NAME"
          DOCKER_IMAGE="${{ env.IMAGE_TAG }}"
          ENVIRONMENT="${{ env.DEPLOYMENT_ENV }}"
          
          # Create application directory
          echo -e "${YELLOW}ğŸ“ Setting up application directory...${NC}"
          mkdir -p $APP_DIR
          cd $APP_DIR
          
          # Stop existing containers
          echo -e "${YELLOW}ğŸ›‘ Stopping existing containers...${NC}"
          docker-compose down --remove-orphans || true
          
          # Login to registry
          echo -e "${YELLOW}ğŸ” Logging into container registry...${NC}"
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          
          # Pull latest image
          echo -e "${YELLOW}ğŸ“¥ Pulling latest Docker image...${NC}"
          docker pull $DOCKER_IMAGE || echo "Failed to pull image, will try to build locally"
          
          # Create docker-compose.yml
          echo -e "${YELLOW}âš™ï¸ Creating Docker Compose configuration...${NC}"
          cat > docker-compose.yml << 'COMPOSE_EOF'
          version: '3.8'
          
          services:
            app:
              image: ${{ env.IMAGE_TAG }}
              container_name: fuseloja-fullstack
              restart: unless-stopped
              ports:
                - "3000:3000"
              environment:
                - NODE_ENV=production
                - PORT=3000
                - DATABASE_URL=/app/data/app.db
                - JWT_SECRET=${{ secrets.JWT_SECRET }}
                - JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}
                - EMAIL_HOST=${{ secrets.EMAIL_HOST }}
                - EMAIL_PORT=${{ secrets.EMAIL_PORT }}
                - EMAIL_USER=${{ secrets.EMAIL_USER }}
                - EMAIL_PASSWORD=${{ secrets.EMAIL_PASSWORD }}
                - CORS_ORIGINS=${{ vars.CORS_ORIGINS }}
              volumes:
                - ./data:/app/data
                - ./uploads:/app/uploads
                - ./logs:/app/logs
                - ./backups:/app/backups
                - /var/www/html:/app/public
              networks:
                - app-network
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
          
          networks:
            app-network:
              driver: bridge
          
          volumes:
            data:
            uploads:
            logs:
            backups:
          COMPOSE_EOF
          
          # Create directories
          echo -e "${YELLOW}ğŸ“ Creating data directories...${NC}"
          mkdir -p data uploads logs backups ssl
          chown -R 1001:1001 data uploads logs backups || true
          
          # Start services
          echo -e "${YELLOW}ğŸš€ Starting services...${NC}"
          docker-compose up -d
          
          # Wait for services to be ready
          echo -e "${YELLOW}â³ Waiting for services to be ready...${NC}"
          sleep 30
          
          # Health check
          echo -e "${YELLOW}ğŸ” Running health check...${NC}"
          max_attempts=10
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
              if curl -f http://localhost:3000/health > /dev/null 2>&1; then
                  echo -e "${GREEN}âœ… Backend is healthy!${NC}"
                  break
              else
                  echo -e "${YELLOW}â³ Attempt $attempt/$max_attempts - Backend not ready yet...${NC}"
                  sleep 10
                  attempt=$((attempt + 1))
              fi
          done
          
          if [ $attempt -gt $max_attempts ]; then
              echo -e "${RED}âŒ Health check failed after $max_attempts attempts${NC}"
              docker-compose logs app
              exit 1
          fi
          
          # Clean up old images
          echo -e "${YELLOW}ğŸ§¹ Cleaning up old Docker images...${NC}"
          docker image prune -f
          
          echo -e "${GREEN}ğŸ‰ Deployment completed successfully!${NC}"
          echo -e "${GREEN}ğŸ“Š Service status:${NC}"
          docker-compose ps

    - name: ğŸ”’ Setup SSL Certificate
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.SSH_HOST }}
        username: ${{ secrets.SSH_USERNAME }}
        password: ${{ secrets.SSH_PASSWORD }}
        port: 22
        script: |
          # Install Certbot if not exists
          if ! command -v certbot &> /dev/null; then
            apt update
            apt install -y certbot python3-certbot-nginx
          fi
          
          # Configure Nginx for SSL
          if [ ! -f /etc/nginx/sites-available/fuseloja-fullstack ]; then
            echo "âš ï¸ Nginx configuration not found. SSL will be configured after running VPS setup script."
            exit 0
          fi
          
          # Get SSL certificate
          certbot --nginx \
            -d ${{ vars.DOMAIN_NAME }} \
            -d fuseloja.com.br \
            --non-interactive \
            --agree-tos \
            --email admin@fuseloja.com.br \
            --redirect || {
            echo "âš ï¸ SSL certificate setup failed. This may be because DNS is not configured yet."
            echo "SSL can be configured later by running: certbot --nginx -d ${{ vars.DOMAIN_NAME }}"
          }
          
          # Setup SSL renewal cron job
          (crontab -l 2>/dev/null; echo "0 12 * * * /usr/bin/certbot renew --quiet --nginx") | crontab -

    - name: ğŸ§ª Post-deployment verification
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.SSH_HOST }}
        username: ${{ secrets.SSH_USERNAME }}
        password: ${{ secrets.SSH_PASSWORD }}
        port: 22
        script: |
          echo "ğŸ” Running post-deployment verification..."
          
          # Test local health endpoint
          if curl -f "http://localhost:3000/health"; then
            echo "âœ… Local backend health endpoint working"
          else
            echo "âŒ Local backend health endpoint not working"
          fi
          
          # Test if domain is configured
          if nslookup ${{ vars.DOMAIN_NAME }} > /dev/null 2>&1; then
            echo "âœ… Domain DNS is configured"
            
            # Test HTTP endpoint if domain is configured
            if curl -f "http://${{ vars.DOMAIN_NAME }}/health" > /dev/null 2>&1; then
              echo "âœ… HTTP endpoint working"
            else
              echo "âŒ HTTP endpoint not working"
            fi
            
            # Test HTTPS endpoint if SSL is configured
            if curl -f "https://${{ vars.DOMAIN_NAME }}/health" > /dev/null 2>&1; then
              echo "âœ… HTTPS endpoint working"
            else
              echo "âŒ HTTPS endpoint not working (SSL may not be configured yet)"
            fi
            
            # Test API endpoint
            if curl -f "http://${{ vars.DOMAIN_NAME }}/api/v1/health" > /dev/null 2>&1; then
              echo "âœ… API endpoint working"
            else
              echo "âŒ API endpoint not working"
            fi
          else
            echo "âš ï¸ Domain DNS not configured yet. Please configure DNS to point to this server."
            echo "ğŸ–¥ï¸ Server IP: $(curl -s ifconfig.me)"
          fi
          
          # Show service status
          echo "ğŸ“Š Service status:"
          cd /opt/fuseloja-fullstack
          docker-compose ps

  # Job 4: Notify
  notify:
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    
    steps:
    - name: ğŸ“§ Notify deployment success
      if: needs.deploy.result == 'success'
      run: |
        echo "ğŸ‰ Deployment to Hostinger VPS completed successfully!"
        echo "ğŸŒ Application URL: https://${{ vars.DOMAIN_NAME }}"
        echo "ğŸ“Š API Health: https://${{ vars.DOMAIN_NAME }}/health"
        echo "ğŸ“š API Docs: https://${{ vars.DOMAIN_NAME }}/api-docs"

    - name: ğŸ“§ Notify deployment failure
      if: needs.deploy.result == 'failure'
      run: |
        echo "âŒ Deployment to Hostinger VPS failed!"
        echo "Please check the deployment logs for details."

  # Job 5: Cleanup
  cleanup:
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    
    steps:
    - name: ğŸ§¹ Clean up old container images
      uses: actions/delete-package-versions@v4
      with:
        package-name: ${{ github.event.repository.name }}/backend
        package-type: 'container'
        min-versions-to-keep: 5
        delete-only-untagged-versions: 'true'
      continue-on-error: true 